C:/Users/matth/Desktop/1-DSM/Research/REACT-BUILD/my-app/src/components/ConfigurationPanel/ConfigurationPanel.css:
/* src/components/ConfigurationPanel/ConfigurationPanel.css */

.config-section {
  text-align: left;
  max-width: 1200px; /* Increased max-width for wider screens */
  margin: 0 auto 30px;
  padding: 25px;
  border: 1px solid var(--border-color);
  border-radius: 10px;
  background-color: var(--primary-color);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.config-section h2 {
  margin-top: 0;
  color: var(--accent-color);
}

.config-section p {
  color: var(--secondary-text-color);
  line-height: 1.6;
}

/* Submit Button */
.config-section button {
  background-color: var(--button-background);
  color: var(--text-color);
  border: none;
  padding: 12px 20px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
  transition: background-color 0.3s, transform 0.2s;
}

.config-section button:hover {
  background-color: var(--button-hover);
  transform: translateY(-2px);
}

.config-section button:disabled {
  background-color: #555555;
  cursor: not-allowed;
}



C:/Users/matth/Desktop/1-DSM/Research/REACT-BUILD/my-app/src/components/ConfigurationPanel/ConfigurationPanel.js:
// src/components/ConfigurationPanel/ConfigurationPanel.js
import React from 'react';
import './ConfigurationPanel.css'; // Updated path

const ConfigurationPanel = ({ columns, onSubmit, loading }) => {
  return (
    <div className="config-section">
      <h2>Configuration</h2>
      <p>
        Drag connections between columns to define relationships. After connecting, specify the relationship type and features.
      </p>
      <button onClick={onSubmit} disabled={loading}>
        {loading ? 'Processing...' : 'Submit Configuration'}
      </button>
    </div>
  );
};

export default ConfigurationPanel;



C:/Users/matth/Desktop/1-DSM/Research/REACT-BUILD/my-app/src/components/FileUploader/FileUploader.css:
/* src/components/FileUploader/FileUploader.css */

.dropzone {
  border: 2px dashed var(--dropzone-border);
  border-radius: 10px;
  padding: 40px;
  cursor: pointer;
  margin-bottom: 20px;
  background-color: var(--dropzone-background);
  transition: background-color 0.3s, border-color 0.3s;
}

.dropzone:hover {
  background-color: var(--secondary-color);
  border-color: var(--accent-color);
}

.dropzone p {
  margin: 0;
  font-size: 16px;
  color: var(--secondary-text-color);
}



C:/Users/matth/Desktop/1-DSM/Research/REACT-BUILD/my-app/src/components/FileUploader/FileUploader.js:
// src/components/FileUploader/FileUploader.js
import React from 'react';
import { useDropzone } from 'react-dropzone';
import Papa from 'papaparse';
import './FileUploader.css'; // Updated path

const FileUploader = ({ onFileDrop }) => {
  const onDrop = (acceptedFiles) => {
    if (acceptedFiles.length === 0) return;
    const file = acceptedFiles[0];
    Papa.parse(file, {
      header: true,
      dynamicTyping: true,
      complete: (results) => {
        onFileDrop(results.data, results.meta.fields);
      },
      error: (error) => {
        console.error('Error parsing CSV:', error);
      },
    });
  };

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: '.csv',
  });

  return (
    <div {...getRootProps()} className="dropzone">
      <input {...getInputProps()} />
      {isDragActive ? (
        <p>Drop the CSV file here...</p>
      ) : (
        <p>Drag and drop a CSV file here, or click to select file</p>
      )}
    </div>
  );
};

export default FileUploader;



C:/Users/matth/Desktop/1-DSM/Research/REACT-BUILD/my-app/src/components/GraphVisualizer/GraphVisualizer.css:
/* src/components/GraphVisualizer/GraphVisualizer.css */

.graph-section {
  text-align: center;
  margin-top: 40px;
}

.graph-section h2 {
  color: var(--accent-color);
  margin-bottom: 20px;
}

.graph-container {
  width: 100%;
  max-width: 1800px; /* Increased max-width for wider screens */
  margin: 0 auto;
  border: 1px solid var(--border-color);
  border-radius: 10px;
  overflow: hidden;
  background-color: var(--primary-color);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  aspect-ratio: 3 / 2; /* Ensures a 3:2 aspect ratio */
}

/* ForceGraph2D Styling */
.graph-section canvas {
  background-color: var(--primary-color) !important;
}



C:/Users/matth/Desktop/1-DSM/Research/REACT-BUILD/my-app/src/components/GraphVisualizer/GraphVisualizer.js:
// src/components/GraphVisualizer/GraphVisualizer.js
import React from 'react';
import ForceGraph2D from 'react-force-graph-2d';
import './GraphVisualizer.css'; // Updated path

const GraphVisualizer = ({ graphData, dimensions }) => {
  return (
    <div className="graph-section">
      <h2>Graph Visualization</h2>
      <div className="graph-container">
        <ForceGraph2D
          graphData={graphData}
          nodeAutoColorBy="type"
          linkAutoColorBy="type"
          nodeLabel="id"
          linkLabel="type"
          nodeVal={(node) => node.val}
          linkDirectionalArrowLength={graphData.directed ? 6 : 0}
          linkDirectionalArrowRelPos={0.5}
          width={dimensions.width}
          height={dimensions.height}
          cooldownTicks={300}
          enableNodeDrag={true}
          enableZoomPanInteraction={true}
          backgroundColor={null}
        />
      </div>
    </div>
  );
};

export default GraphVisualizer;



C:/Users/matth/Desktop/1-DSM/Research/REACT-BUILD/my-app/src/components/output.txt:
./ConfigurationPanel/ConfigurationPanel.css:
/* src/components/ConfigurationPanel/ConfigurationPanel.css */

.config-section {
  text-align: left;
  max-width: 1200px; /* Increased max-width for wider screens */
  margin: 0 auto 30px;
  padding: 25px;
  border: 1px solid var(--border-color);
  border-radius: 10px;
  background-color: var(--primary-color);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.config-section h2 {
  margin-top: 0;
  color: var(--accent-color);
}

.config-section p {
  color: var(--secondary-text-color);
  line-height: 1.6;
}

/* Submit Button */
.config-section button {
  background-color: var(--button-background);
  color: var(--text-color);
  border: none;
  padding: 12px 20px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
  transition: background-color 0.3s, transform 0.2s;
}

.config-section button:hover {
  background-color: var(--button-hover);
  transform: translateY(-2px);
}

.config-section button:disabled {
  background-color: #555555;
  cursor: not-allowed;
}



./ConfigurationPanel/ConfigurationPanel.js:
// src/components/ConfigurationPanel/ConfigurationPanel.js
import React from 'react';
import './ConfigurationPanel.css'; // Updated path

const ConfigurationPanel = ({ columns, onSubmit, loading }) => {
  return (
    <div className="config-section">
      <h2>Configuration</h2>
      <p>
        Drag connections between columns to define relationships. After connecting, specify the relationship type and features.
      </p>
      <button onClick={onSubmit} disabled={loading}>
        {loading ? 'Processing...' : 'Submit Configuration'}
      </button>
    </div>
  );
};

export default ConfigurationPanel;



./FileUploader/FileUploader.css:
/* src/components/FileUploader/FileUploader.css */

.dropzone {
  border: 2px dashed var(--dropzone-border);
  border-radius: 10px;
  padding: 40px;
  cursor: pointer;
  margin-bottom: 20px;
  background-color: var(--dropzone-background);
  transition: background-color 0.3s, border-color 0.3s;
}

.dropzone:hover {
  background-color: var(--secondary-color);
  border-color: var(--accent-color);
}

.dropzone p {
  margin: 0;
  font-size: 16px;
  color: var(--secondary-text-color);
}



./FileUploader/FileUploader.js:
// src/components/FileUploader/FileUploader.js
import React from 'react';
import { useDropzone } from 'react-dropzone';
import Papa from 'papaparse';
import './FileUploader.css'; // Updated path

const FileUploader = ({ onFileDrop }) => {
  const onDrop = (acceptedFiles) => {
    if (acceptedFiles.length === 0) return;
    const file = acceptedFiles[0];
    Papa.parse(file, {
      header: true,
      dynamicTyping: true,
      complete: (results) => {
        onFileDrop(results.data, results.meta.fields);
      },
      error: (error) => {
        console.error('Error parsing CSV:', error);
      },
    });
  };

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: '.csv',
  });

  return (
    <div {...getRootProps()} className="dropzone">
      <input {...getInputProps()} />
      {isDragActive ? (
        <p>Drop the CSV file here...</p>
      ) : (
        <p>Drag and drop a CSV file here, or click to select file</p>
      )}
    </div>
  );
};

export default FileUploader;



./GraphVisualizer/GraphVisualizer.css:
/* src/components/GraphVisualizer/GraphVisualizer.css */

.graph-section {
  text-align: center;
  margin-top: 40px;
}

.graph-section h2 {
  color: var(--accent-color);
  margin-bottom: 20px;
}

.graph-container {
  width: 100%;
  max-width: 1800px; /* Increased max-width for wider screens */
  margin: 0 auto;
  border: 1px solid var(--border-color);
  border-radius: 10px;
  overflow: hidden;
  background-color: var(--primary-color);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  aspect-ratio: 3 / 2; /* Ensures a 3:2 aspect ratio */
}

/* ForceGraph2D Styling */
.graph-section canvas {
  background-color: var(--primary-color) !important;
}



./GraphVisualizer/GraphVisualizer.js:
// src/components/GraphVisualizer/GraphVisualizer.js
import React from 'react';
import ForceGraph2D from 'react-force-graph-2d';
import './GraphVisualizer.css'; // Updated path

const GraphVisualizer = ({ graphData, dimensions }) => {
  return (
    <div className="graph-section">
      <h2>Graph Visualization</h2>
      <div className="graph-container">
        <ForceGraph2D
          graphData={graphData}
          nodeAutoColorBy="type"
          linkAutoColorBy="type"
          nodeLabel="id"
          linkLabel="type"
          nodeVal={(node) => node.val}
          linkDirectionalArrowLength={graphData.directed ? 6 : 0}
          linkDirectionalArrowRelPos={0.5}
          width={dimensions.width}
          height={dimensions.height}
          cooldownTicks={300}
          enableNodeDrag={true}
          enableZoomPanInteraction={true}
          backgroundColor={null}
        />
      </div>
    </div>
  );
};

export default GraphVisualizer;



./RelationshipModal/RelationshipModal.css:
/* src/components/RelationshipModal/RelationshipModal.css */

.relationship-modal {
  position: absolute;
  top: 50%;
  left: 50%;
  right: auto;
  bottom: auto;
  transform: translate(-50%, -50%);
  background-color: var(--modal-background);
  padding: 25px;
  border-radius: 8px;
  width: 90%;
  max-width: 400px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
  color: var(--text-color);
  z-index: 1000;
  transition: opacity 0.3s ease-in-out;
  overflow-y: auto;
  max-height: 90vh;
}

.overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0,0,0,0.7);
  z-index: 999;
}

.relationship-modal h2 {
  margin-top: 0;
  color: var(--accent-color);
  margin-bottom: 20px;
  text-align: center;
}

.relationship-modal form {
  display: flex;
  flex-direction: column;
}

.relationship-modal label {
  margin-bottom: 15px;
  text-align: left;
  font-weight: bold;
  color: var(--text-color);
}

.relationship-type-input {
  width: 100%;
  padding: 8px;
  margin-top: 5px;
  background-color: var(--input-background);
  color: var(--input-text-color);
  border: 1px solid var(--border-color);
  border-radius: 5px;
  outline: none;
  transition: border-color 0.3s;
}

.relationship-type-input:focus {
  border-color: var(--accent-color);
}

.relationship-features-select {
  width: 100%;
  height: 100px;
  padding: 8px;
  margin-top: 5px;
  background-color: var(--select-background);
  color: var(--select-text-color);
  border: 1px solid var(--border-color);
  border-radius: 5px;
  outline: none;
  transition: border-color 0.3s;
  overflow-y: auto;
}

.relationship-features-select:focus {
  border-color: var(--accent-color);
}

.relationship-features-select option {
  background-color: var(--primary-color);
  color: var(--text-color);
}

.modal-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;
}

.modal-buttons button {
  padding: 8px 16px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.3s, transform 0.2s;
}

.modal-buttons button:first-child {
  background-color: var(--button-background);
  color: var(--text-color);
}

.modal-buttons button:first-child:hover {
  background-color: var(--button-hover);
  transform: translateY(-2px);
}

.modal-buttons button:last-child {
  background-color: #e74c3c; /* Cancel Button - Red */
  color: #ffffff;
}

.modal-buttons button:last-child:hover {
  background-color: #c82333;
  transform: translateY(-2px);
}



./RelationshipModal/RelationshipModal.js:
// src/components/RelationshipModal/RelationshipModal.js
import React, { useState, useEffect } from 'react';
import Modal from 'react-modal';
import './RelationshipModal.css'; // Updated path

Modal.setAppElement('#root'); // For accessibility

const RelationshipModal = ({
  isOpen,
  onRequestClose,
  columns,
  onSaveRelationship,
}) => {
  const [relationshipType, setRelationshipType] = useState('');
  const [relationshipFeatures, setRelationshipFeatures] = useState([]);

  useEffect(() => {
    if (isOpen) {
      setRelationshipType('');
      setRelationshipFeatures([]);
    }
  }, [isOpen]);

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!relationshipType.trim()) {
      alert('Please enter a relationship type.');
      return;
    }
    onSaveRelationship({ relationshipType, relationshipFeatures });
    // Reset modal state
    setRelationshipType('');
    setRelationshipFeatures([]);
  };

  const handleFeatureChange = (e) => {
    const selectedOptions = Array.from(e.target.selectedOptions).map(option => option.value);
    setRelationshipFeatures(selectedOptions);
  };

  return (
    <Modal
      isOpen={isOpen}
      onRequestClose={onRequestClose}
      contentLabel="Relationship Configuration"
      className="relationship-modal"
      overlayClassName="overlay"
    >
      <h2>Configure Relationship</h2>
      <form onSubmit={handleSubmit}>
        <label>
          Relationship Type:
          <input
            type="text"
            value={relationshipType}
            onChange={(e) => setRelationshipType(e.target.value)}
            required
            className="relationship-type-input"
            placeholder="e.g., connects, influences"
          />
        </label>
        <label>
          Features:
          <select
            multiple
            value={relationshipFeatures}
            onChange={handleFeatureChange}
            className="relationship-features-select"
          >
            {columns.map((col) => (
              <option key={col} value={col}>
                {col}
              </option>
            ))}
          </select>
        </label>
        <div className="modal-buttons">
          <button type="submit">Save</button>
          <button type="button" onClick={onRequestClose}>
            Cancel
          </button>
        </div>
      </form>
    </Modal>
  );
};

export default RelationshipModal;






C:/Users/matth/Desktop/1-DSM/Research/REACT-BUILD/my-app/src/components/ReactFlowWrapper/ReactFlowWrapper.css:
/* src/components/ReactFlowWrapper/ReactFlowWrapper.module.css */

.wrapper {
  height: 60vh; /* 60% of the viewport height */
  width: 90%;
  max-width: 1200px;
  margin: 0 auto 30px;
  border: 1px solid var(--border-color);
  border-radius: 10px;
  background-color: var(--primary-color);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  /* Removed padding to prevent node overflow */
  position: relative; /* Ensures React Flow positions correctly */
}

@media (max-width: 1200px) {
  .wrapper {
    width: 95%;
  }
}

@media (max-width: 768px) {
  .wrapper {
    height: 50vh; /* Reduce height on smaller screens */
  }
}

/* Node Styling */
.node {
  background-color: var(--secondary-color);
  color: var(--text-color);
  border: 1px solid var(--border-color);
  border-radius: 5px;
  padding: 10px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  transition: transform 0.2s, box-shadow 0.3s;
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
}

.node:hover {
  transform: scale(1.05);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
}

/* Edge Styling */
.edgePath {
  stroke: var(--accent-color);
  stroke-width: 2px;
}

.edgeArrowhead {
  fill: var(--accent-color);
}



C:/Users/matth/Desktop/1-DSM/Research/REACT-BUILD/my-app/src/components/ReactFlowWrapper/ReactFlowWrapper.js:
// src/components/ReactFlowWrapper/ReactFlowWrapper.js
import React from 'react';
import ReactFlow from 'react-flow-renderer';
import './ReactFlowWrapper.css'; // Correct Import
import 'react-flow-renderer/dist/style.css'; // Import React Flow's default styles

const ReactFlowWrapper = ({ nodes, edges, onNodesChange, onEdgesChange, onConnect }) => {
  return (
    <div className={'wrapper'}>
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        deleteKeyCode={46} /* 'delete'-key */
        fitView
        style={{ width: '100%', height: '100%' }}
      />
    </div>
  );
};

export default ReactFlowWrapper;



C:/Users/matth/Desktop/1-DSM/Research/REACT-BUILD/my-app/src/components/RelationshipModal/RelationshipModal.css:
/* src/components/RelationshipModal/RelationshipModal.css */

.relationship-modal {
  position: absolute;
  top: 50%;
  left: 50%;
  right: auto;
  bottom: auto;
  transform: translate(-50%, -50%);
  background-color: var(--modal-background);
  padding: 25px;
  border-radius: 8px;
  width: 90%;
  max-width: 400px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
  color: var(--text-color);
  z-index: 1000;
  transition: opacity 0.3s ease-in-out;
  overflow-y: auto;
  max-height: 90vh;
}

.overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0,0,0,0.7);
  z-index: 999;
}

.relationship-modal h2 {
  margin-top: 0;
  color: var(--accent-color);
  margin-bottom: 20px;
  text-align: center;
}

.relationship-modal form {
  display: flex;
  flex-direction: column;
}

.relationship-modal label {
  margin-bottom: 15px;
  text-align: left;
  font-weight: bold;
  color: var(--text-color);
}

.relationship-type-input {
  width: 100%;
  padding: 8px;
  margin-top: 5px;
  background-color: var(--input-background);
  color: var(--input-text-color);
  border: 1px solid var(--border-color);
  border-radius: 5px;
  outline: none;
  transition: border-color 0.3s;
}

.relationship-type-input:focus {
  border-color: var(--accent-color);
}

.relationship-features-select {
  width: 100%;
  height: 100px;
  padding: 8px;
  margin-top: 5px;
  background-color: var(--select-background);
  color: var(--select-text-color);
  border: 1px solid var(--border-color);
  border-radius: 5px;
  outline: none;
  transition: border-color 0.3s;
  overflow-y: auto;
}

.relationship-features-select:focus {
  border-color: var(--accent-color);
}

.relationship-features-select option {
  background-color: var(--primary-color);
  color: var(--text-color);
}

.modal-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;
}

.modal-buttons button {
  padding: 8px 16px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 14px;
  transition: background-color 0.3s, transform 0.2s;
}

.modal-buttons button:first-child {
  background-color: var(--button-background);
  color: var(--text-color);
}

.modal-buttons button:first-child:hover {
  background-color: var(--button-hover);
  transform: translateY(-2px);
}

.modal-buttons button:last-child {
  background-color: #e74c3c; /* Cancel Button - Red */
  color: #ffffff;
}

.modal-buttons button:last-child:hover {
  background-color: #c82333;
  transform: translateY(-2px);
}



C:/Users/matth/Desktop/1-DSM/Research/REACT-BUILD/my-app/src/components/RelationshipModal/RelationshipModal.js:
// src/components/RelationshipModal/RelationshipModal.js
import React, { useState, useEffect } from 'react';
import Modal from 'react-modal';
import './RelationshipModal.css'; // Updated path

Modal.setAppElement('#root'); // For accessibility

const RelationshipModal = ({
  isOpen,
  onRequestClose,
  columns,
  onSaveRelationship,
}) => {
  const [relationshipType, setRelationshipType] = useState('');
  const [relationshipFeatures, setRelationshipFeatures] = useState([]);

  useEffect(() => {
    if (isOpen) {
      setRelationshipType('');
      setRelationshipFeatures([]);
    }
  }, [isOpen]);

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!relationshipType.trim()) {
      alert('Please enter a relationship type.');
      return;
    }
    onSaveRelationship({ relationshipType, relationshipFeatures });
    // Reset modal state
    setRelationshipType('');
    setRelationshipFeatures([]);
  };

  const handleFeatureChange = (e) => {
    const selectedOptions = Array.from(e.target.selectedOptions).map(option => option.value);
    setRelationshipFeatures(selectedOptions);
  };

  return (
    <Modal
      isOpen={isOpen}
      onRequestClose={onRequestClose}
      contentLabel="Relationship Configuration"
      className="relationship-modal"
      overlayClassName="overlay"
    >
      <h2>Configure Relationship</h2>
      <form onSubmit={handleSubmit}>
        <label>
          Relationship Type:
          <input
            type="text"
            value={relationshipType}
            onChange={(e) => setRelationshipType(e.target.value)}
            required
            className="relationship-type-input"
            placeholder="e.g., connects, influences"
          />
        </label>
        <label>
          Features:
          <select
            multiple
            value={relationshipFeatures}
            onChange={handleFeatureChange}
            className="relationship-features-select"
          >
            {columns.map((col) => (
              <option key={col} value={col}>
                {col}
              </option>
            ))}
          </select>
        </label>
        <div className="modal-buttons">
          <button type="submit">Save</button>
          <button type="button" onClick={onRequestClose}>
            Cancel
          </button>
        </div>
      </form>
    </Modal>
  );
};

export default RelationshipModal;



C:/Users/matth/Desktop/1-DSM/Research/REACT-BUILD/my-app-backend/main.py:
# my-app-backend/main.py
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import pandas as pd
from fastapi.middleware.cors import CORSMiddleware
from typing import List, Dict, Any
import networkx as nx
from networkx.readwrite import json_graph
from Tabular_to_Graph import DataFrameToGraph  # Ensure this class is accessible
# To boot server use: uvicorn main:app --reload

app = FastAPI()

# CORS Configuration
origins = [
    "http://localhost:3000",  # React app origin
    # Add other origins if needed
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Data Model
class DataModel(BaseModel):
    data: List[Dict[str, Any]]  # List of dictionaries representing CSV rows
    config: Dict[str, Any]      # Configuration dictionary

@app.get("/")
def read_root():
    return {"message": "Hello from the Python Backend!"}

@app.post("/process-data")
def process_data(model: DataModel):
    try:
        df = pd.DataFrame(model.data)
        config = model.config
        graph_type = config.get('graph_type', 'directed')  # Optional graph type

        # Initialize DataFrameToGraph
        df_to_graph = DataFrameToGraph(df, config, graph_type=graph_type)
        graph = df_to_graph.get_graph()

        # Serialize graph to node-link format
        graph_data = json_graph.node_link_data(graph)
        
        return {"graph": graph_data}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))



C:/Users/matth/Desktop/1-DSM/Research/REACT-BUILD/my-app-backend/Tabular_to_Graph.py:

import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt
from typing import Dict, Any, List, Tuple, Optional
import logging
import matplotlib.patches as mpatches
import matplotlib.cm as cm
import matplotlib.colors as colors

# Set up logging
# Set up logging to file instead of console
logging.basicConfig(
    level=logging.INFO,
    filename='app.log',         # Specify the file name for the log file
    filemode='w',               # 'w' for write mode, 'a' for append mode
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class DataFrameToGraph:
    def __init__(self, 
                 df: pd.DataFrame, 
                 config: Dict[str, Any],
                 graph_type: str = 'directed'):
        """
        Initializes the DataFrameToGraph instance.

        Parameters:
        - df (pd.DataFrame): The input DataFrame containing tabular data.
        - config (Dict[str, Any]): Configuration dictionary defining column roles.
        - graph_type (str): Type of the graph ('directed' or 'undirected').
        """
        self.df = df
        self.config = config
        self.graph_type = graph_type.lower()
        self.graph = self._initialize_graph()
        self.node_registry = {}
        self.edge_registry = {}
        
        self._validate_config()
        self._parse_dataframe()

    def _initialize_graph(self) -> nx.Graph:
        """Initializes the NetworkX graph based on the specified type."""
        if self.graph_type == 'directed':
            return nx.MultiDiGraph()
        elif self.graph_type == 'undirected':
            return nx.MultiGraph()
        else:
            raise ValueError("graph_type must be 'directed' or 'undirected'.")

    def _validate_config(self):
        """Validates the configuration dictionary."""
        required_keys = ['nodes', 'relationships']
        for key in required_keys:
            if key not in self.config:
                raise KeyError(f"Configuration missing required key: '{key}'")
        
        # Validate nodes configuration
        for node_conf in self.config['nodes']:
            if 'id' not in node_conf:
                raise KeyError("Each node configuration must have an 'id' key.")
            if 'type' not in node_conf:
                logger.warning(f"Node configuration {node_conf} missing 'type'. Defaulting to 'default'.")

        # Validate relationships configuration
        for rel_conf in self.config['relationships']:
            if 'source' not in rel_conf or 'target' not in rel_conf:
                raise KeyError("Each relationship configuration must have 'source' and 'target' keys.")
            if 'type' not in rel_conf:
                logger.warning(f"Relationship configuration {rel_conf} missing 'type'. Defaulting to 'default'.")

    def _parse_dataframe(self):
        """Parses the DataFrame and constructs the graph."""
        for index, row in self.df.iterrows():
            # Add nodes
            for node_conf in self.config['nodes']:
                node_id = row.get(node_conf['id'], None)
                if pd.isnull(node_id):
                    logger.warning(f"Row {index}: Missing node ID for '{node_conf['id']}'. Skipping node addition.")
                    continue
                # Convert node_id to string for consistency
                node_id_str = str(int(node_id)) if isinstance(node_id, float) and node_id.is_integer() else str(node_id)
                node_type = node_conf.get('type', 'default')
                features = self._extract_features(row, node_conf.get('features', []))
                self._add_node(node_id_str, node_type, features)
            
            # Add edges
            for rel_conf in self.config['relationships']:
                source_col = rel_conf['source']
                target_col = rel_conf['target']
                relationship_type = rel_conf.get('type', 'default')
                features = self._extract_features(row, rel_conf.get('features', []))
                
                source_id = row.get(source_col, None)
                target_id = row.get(target_col, None)
                
                if pd.isnull(source_id) or pd.isnull(target_id):
                    logger.warning(f"Row {index}: Missing source or target ID for relationship '{relationship_type}'. Skipping edge addition.")
                    continue
                
                # Handle inconsistent data types
                try:
                    source_id = int(source_id)
                    source_id_str = str(source_id)
                except (ValueError, TypeError):
                    logger.warning(f"Row {index}: Invalid data type for source_id '{source_id}'. Skipping edge addition.")
                    continue

                try:
                    if isinstance(target_id, float) and target_id.is_integer():
                        target_id = int(target_id)
                    target_id_str = str(target_id)
                except (ValueError, TypeError):
                    logger.warning(f"Row {index}: Invalid data type for target_id '{target_id}'. Skipping edge addition.")
                    continue

                self._add_edge(source_id_str, target_id_str, relationship_type, features)

    def _extract_features(self, row: pd.Series, feature_cols: List[str]) -> Dict[str, Any]:
        """Extracts feature data from the row based on specified columns."""
        features = {}
        for feat in feature_cols:
            if feat in row:
                value = row[feat]
                if isinstance(value, list):
                    # Assume the list is present and valid
                    features[feat] = value
                elif pd.isnull(value):
                    logger.info(f"Feature '{feat}' is missing in row. Assigning default value.")
                    features[feat] = ""
                else:
                    features[feat] = value
            else:
                logger.info(f"Feature '{feat}' not found in row. Assigning default value.")
                features[feat] = ""
        return features

    def _add_node(self, node_id: str, node_type: str, features: Dict[str, Any]):
        """
        Adds a node to the graph or updates its features if it already exists.

        Parameters:
        - node_id (str): Unique identifier for the node.
        - node_type (str): Type/category of the node.
        - features (Dict[str, Any]): Features to assign to the node.
        """
        if node_id not in self.node_registry:
            self.node_registry[node_id] = {'type': node_type, 'features': features}
            self.graph.add_node(node_id, type=node_type, **features)
            logger.info(f"Added node {node_id} of type '{node_type}'.")
        else:
            # Update existing node features
            existing_features = self.node_registry[node_id]['features']
            updated_features = {k: v for k, v in features.items() if v != ""}
            existing_features.update(updated_features)
            self.graph.nodes[node_id].update(updated_features)
            logger.info(f"Updated node {node_id} with features {updated_features}.")

    def _add_edge(self, source_id: str, target_id: str, rel_type: str, features: Dict[str, Any]):
        """
        Adds an edge to the graph or updates its features if it already exists.

        Parameters:
        - source_id (str): Source node identifier.
        - target_id (str): Target node identifier.
        - rel_type (str): Type/category of the relationship.
        - features (Dict[str, Any]): Features to assign to the edge.
        """
        edge_key = (source_id, target_id, rel_type)
        if self.graph_type == 'undirected':
            edge_key = tuple(sorted([source_id, target_id])) + (rel_type,)
        
        if not self.graph.has_edge(source_id, target_id, key=rel_type):
            self.edge_registry[edge_key] = features
            self.graph.add_edge(source_id, target_id, key=rel_type, type=rel_type, **features)
            logger.info(f"Added edge from {source_id} to {target_id} of type '{rel_type}'.")
        else:
            # Update existing edge features
            existing_features = self.edge_registry.get(edge_key, {})
            updated_features = {k: v for k, v in features.items() if v != ""}
            existing_features.update(updated_features)
            self.edge_registry[edge_key] = existing_features
            self.graph[source_id][target_id][rel_type].update(updated_features)
            logger.info(f"Updated edge from {source_id} to {target_id} of type '{rel_type}' with features {updated_features}.")

    def get_graph(self) -> nx.Graph:
        """Returns the constructed NetworkX graph."""
        return self.graph

    def export_graph(self, format: str = 'adjacency', path: Optional[str] = None):
        """
        Exports the graph in the specified format.

        Parameters:
        - format (str): The format to export the graph ('adjacency', 'edge_list', etc.).
        - path (str): File path to save the exported graph. If None, returns the data.

        Returns:
        - The exported graph data if path is None.
        """
        if format == 'adjacency':
            data = nx.to_dict_of_dicts(self.graph)
        elif format == 'edge_list':
            # For MultiGraph/MultiDiGraph, each edge is represented with (source, target, key, data)
            # We'll flatten this for the edge list
            edges = []
            for source, target, key, attrs in self.graph.edges(keys=True, data=True):
                edge_data = {
                    'source': source,
                    'target': target,
                    'key': key
                }
                # Exclude 'type' from attributes to prevent duplication
                edge_attributes = {k: (v if v is not None else "") for k, v in attrs.items() if k != 'type'}
                edge_data.update(edge_attributes)
                edges.append(edge_data)
            data = pd.DataFrame(edges)
        else:
            raise ValueError("Unsupported format. Use 'adjacency' or 'edge_list'.")
        
        if path:
            if format == 'adjacency':
                pd.DataFrame.from_dict(data, orient='index').to_csv(path)
                logger.info(f"Graph exported in adjacency format to '{path}'.")
            elif format == 'edge_list':
                data.to_csv(path, index=False)
                logger.info(f"Graph exported in edge list format to '{path}'.")
        else:
            return data

    def graph_visual(self, graph: nx.Graph):
        """
        Visualizes the NetworkX graph with dynamic node and edge types.

        Parameters:
        - graph (nx.Graph): The NetworkX graph to visualize.
        """
        # Extract unique node types
        node_types = set(data.get('type', 'default') for _, data in graph.nodes(data=True))
        node_type_list = sorted(node_types)  # Sort for consistency

        # Assign colors to node types using a colormap
        cmap_nodes = cm.get_cmap('tab10', len(node_type_list))
        node_type_color_map = {ntype: cmap_nodes(i) for i, ntype in enumerate(node_type_list)}

        # Assign colors to nodes based on their type
        node_colors = [node_type_color_map[data.get('type', 'default')] for _, data in graph.nodes(data=True)]

        # Define node sizes based on node degree
        degrees = dict(graph.degree())
        max_degree = max(degrees.values()) if degrees else 1
        node_sizes = [30 + (degrees[node] / max_degree) * 70 for node in graph.nodes()]  # Scale sizes between 300 and 1000

        # Extract unique edge relationship types
        edge_types = set(data.get('type', 'default') for _, _, data in graph.edges(data=True))
        edge_type_list = sorted(edge_types)  # Sort for consistency

        # Assign colors to edge types using a colormap
        cmap_edges = cm.get_cmap('Set2', len(edge_type_list))
        edge_type_color_map = {etype: cmap_edges(i) for i, etype in enumerate(edge_type_list)}

        # Assign colors to edges based on their type
        edge_colors = [edge_type_color_map[data.get('type', 'default')] for _, _, data in graph.edges(data=True)]

        # Generate positions for all nodes using spring layout for better visualization
        pos = nx.spring_layout(graph, seed=42, k=0.15, iterations=50)

        plt.figure(figsize=(12, 8))
        
        # Draw nodes with dynamic colors and sizes
        nx.draw_networkx_nodes(graph, pos, node_color=node_colors, node_size=node_sizes, alpha=0.9)

        # Draw edges with dynamic colors
        if self.graph_type == 'directed':
            nx.draw_networkx_edges(graph, pos, edge_color=edge_colors, arrows=True, alpha=0.7, width=1.0)
        else:
            nx.draw_networkx_edges(graph, pos, edge_color=edge_colors, alpha=0.7, width=1.0)

        # Optionally, draw labels (commented out for clarity)
        # nx.draw_networkx_labels(graph, pos, font_size=8, font_family='sans-serif')

        # Create legend for node types
        node_patches = [mpatches.Patch(color=node_type_color_map[ntype], label=ntype) for ntype in node_type_list]

        # Create legend for edge types
        edge_patches = [mpatches.Patch(color=edge_type_color_map[etype], label=etype) for etype in edge_type_list]

        # Combine legends
        plt.legend(handles=node_patches + edge_patches, loc='upper right', bbox_to_anchor=(1.3, 1))

        # Remove axis
        plt.axis('off')

        # Set title
        plt.title("Graph Visualization", fontsize=15)

        # Adjust layout to make room for legends
        plt.tight_layout()

        # Display the graph
        plt.show()

def main():

    # Enhanced Sample DataFrame for a Social Network
    df = pd.read_csv('prince-toronto.csv')
    # Configuration Dictionary (Including 'features' Key)
    config = {
        "nodes": [
            {
                "id": "tweet_id",
                "type": "Post",
                "features": ["retweet_count", "lang"]
            },
            {
                "id": "reply_to_tweet_id",  # Added node definition for reply_to_tweet_id
                "type": "Post",
                "features": ["retweet_count", "lang"]
            },
            {
                "id": "user_id",
                "type": "User",
                "features": ["favorite_count", "user_friends_count"]
            }
        ],
        "relationships": [
            {
                "source": "tweet_id",
                "target": "reply_to_tweet_id",
                "type": "replied",
                "features": ["mentions", "hashtags"]
            },
            {
                "source": "user_id",
                "target": "tweet_id",
                "type": "posted",
                "features": ["geo"]
            }
        ]
    }

    # Initialize the DataFrameToGraph instance
    df_to_graph = DataFrameToGraph(df, config, graph_type='directed')
    # Retrieve the constructed graph
    graph = df_to_graph.get_graph()

    # Display nodes with attributes
    print("Nodes:")
    for node, attrs in graph.nodes(data=True):
        print(node, attrs)

    # Display edges with attributes
    print("\nEdges:")
    for source, target, key, attrs in graph.edges(keys=True, data=True):
        print(f"{source} -> {target} [type={attrs.get('type')}, key={key}] {attrs}")

    # Export the graph as an edge list CSV
    df_to_graph.export_graph(format='edge_list', path='graph_edge_list.csv')

    # Alternatively, get the adjacency dictionary
    adjacency_dict = df_to_graph.export_graph(format='adjacency')
    print("\nAdjacency Dictionary:")
    print(adjacency_dict)

    # Visualization Code Starts Here
    # --------------------------------

    # Visualize the graph
    df_to_graph.graph_visual(graph)



if __name__ == "__main__":
    main()


